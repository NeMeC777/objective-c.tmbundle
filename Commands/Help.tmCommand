<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>beforeRunningCommand</key>
	<string>nop</string>
	<key>bundleUUID</key>
	<string>4679484F-6227-11D9-BFB1-000D93589AF6</string>
	<key>command</key>
	<string>. "$TM_SUPPORT_PATH/lib/webpreview.sh"
html_header "Objective-C Bundle Help" "Objective-C"
"$TM_SUPPORT_PATH/lib/markdown_to_help.rb" &lt;&lt;'MARKDOWN'

# Introduction

This document describes the commands of the TextMate Objective-C bundle. Here is a [direct link][1] (3:30 / 8 MB) to a screencast Joachim Mårtensson made, showing some of the newest features:

*   The Code Completion command ( activated with the ⌥⎋ - option escape - key-combo ).
*   The Bracket Matching command ( \] )
*   Reformatting of method calls ( ⌃Q )
*   Documentation Look-up ( ⌃H )

Other screencasts can be found on [Macromates' homepage][2]
    
# The Code Completion Commands

The Code Completion command is activated by the ⌥⎋ option key combination, it will present a popup menu with suggestions based on context, for example within brackets it will give class-, constant-, function- and of course method-completion. 

The command (which is actually three different commands) will consult various list of method names, class names etc. In all the examples below a space before the caret could have been a word before the caret, which would only have narrowed down the list of suggestions further.

## Within Brackets

    [NSObje‸ ]
    
__Will give a list of all Cocoa Classes prefixed with NSObje. i.e. NSObject and NSObjectController.__

    [NSObject ‸]
__Will suggest all class methods that NSObject support out of the box.__
Internally the completion command will ask the class named NSObject to dump all class methods, these are in turn compared with a list of Cocoa methods so that proper argument names can be given, the reason for this comparison is that the Cocoa runtime can not give more information about an object than that it is of type id. If the word before the caret is not a prefix from the class name dump, the completion command will instead default back to giving non context sensitive method names with that prefix.

    [object setV‸]
    
__Will give a list of all Cocoa Methods starting with setV.__
Currently the completion command has no way of knowing what type `object` is of so it will give a list of all methods with the word before the caret, since some prefixes are pretty common (e.g. set) it is usually a smart idea to type a few charachters before invoking the command.

    [object setObject:name forK‸]
    
__Like above it will give a list of all methods, but `setObject:` will be prefixed to the word before the caret.__
The parser that finds method parts is a regexp that checks for a word followed by a colon(:), so if you use short-hand if statements within brackets make sure that you put a space before the : (e.g. `a &gt; 1 ? x : y `). 
    
    [[object string] ‸]
    
__Will suggest all instance methods that NSString supports out of the box.__
The reason that context sensitive method suggestions can be given is that we can check that the method `string` returns an NSString. very few Cocoa methods with the same name return objects of different type so getting faulty method suggestions should be very rare. If the method is not in the method index file standard suggestions are given.

    [object initWithKind:‸]
    
__Will suggest Cocoa functions (currently only AppKit and Foundation) and Cocoa Constants with type NSXMLNodeKind, since that is the argument that `initWithKind:` takes.__
Like the other examples if no function with the correct return type can be found, all functions matching the prefix are suggested. Unfortunately not all constants have a type which will help us with suggestions for arguments, for example all Notification names are of NSString type, but of course it is not very often that we would want them suggested just because a method takes an NSString as an argument. Currently a few methods have been added to a list that is checked against for special behaviour, if someone can think of a better stategy, all suggestions are welcome.

## Outside of Brackets

The completion command will give different completion suggestion depending on what scope the caret is in, to get the name of the current scope press ⌃⇧P. The 6 different scopes that give suggestions are depicted below, ‸\# depicts caret positon. 
    
    @interface MyClass : NSO‸₁ &lt;NSObj‸₂&gt;
    {
        NSSt‸₃
    }
    @end
    @implementation MyClass
    - (id)init
    {
        if(self = [super init])
        {
            NSArr‸₄
        }
        return self;
    }
    - initW‸₅
    - (NSStr‸₆)stringFromString(NSSt‸₆&lt;NSCod‸₂&gt;)
    @end
    
1.  Here the completion command will suggest known Cocoa class names.
2.  Here the completion command will suggest known Cocoa protocol names.
3.  Same as 2 plus a placeholder variable name will be inserted.
4.  Same as 3 plus completion for C/C++/Cocoa functions.
5.  When subclassing a Cocoa Class or implementing a delegate Class it is often useful to be able to not only get method call completion, but also method declaration completion. Putting a minus- or a plus- sign as the first charachter in a line, typing a few charachters and invoking the completion command will present a list of methods that can be inserted. The method declaration will be completed, together with return type and argument types, the names of the arguments will be guessed based on what the argument type is i.e. they will not be the same as the Apple headers.
6.  Same as 1 but a star will be inserted if a class name.
    
# The Bracket Matching Command

When inserting a closing bracket when there is no open bracket, an open bracket will also be inserted. this is probably best explained by showing a few examples. `‸` denotes the caret placement.

    obj mess‸ → [obj mess]
    
    obj mess:arg‸ → [obj mess:arg]
    
When wrapping multipart methods in brackets, the object corresponding to the right most method part will be wrapped

    obj mess:arg other:arg2‸ → obj mess:[arg other:arg2]
    
unless `mess:other:` is a known Cocoa method in which case the whole message will be wrapped instead i.e

    [obj mess:arg other:arg2]
    
arguments to functions and methods are correctly handled

    func(a,obj setSelectedFont:aFont isMultiple:YES‸)
    
Will be turned into:

    func(a,[obj setSelectedFont:aFont isMultiple:YES])
    
since `setSelectedFont:isMultiple:` is a known Cocoa method

    obj‸ → [obj ‸]
    
a single word will be wrapped in brackets and the caret will be placed inside, with an additinal space if there is not already one.

    [obj mess:[arg other:arg2]‸]
    
Will overtype the bracket to the right of the caret, just like standard TextMate behaviour. the exception is if there is an object that could be wrapped that is not already.

    [obj mess:arg other:arg2‸] → [obj mess:[arg other:arg2]]
    
the bracket completion is aware of quite a few C/Objective-C constructs and will not wrap when it does not make (much) sense.

    nil‸ → nil] // no messaging nil
    return self‸ → return [self ‸]
    NSArray arrayWithObjects:names, urls, nil‸ →
    [NSArray arrayWithObjects:names, urls, nil]
    
The bracket matcher basically works like this:

1.  if there is a word to the left of the caret, try to find an object to the left of it.
1.  if 1 failed look for a message that takes an argument i.e `mess:`. If found, try to find even more such messages compare them with known Cocoa methods as we go, if no known Cocoa methods were found we use only the first matched message. try to find an object to the left of the message.
1.  if neither 1 or 2, we have a single object wrap it and insert the caret between the brackets.
    
# Reformatting of Method Calls

Pressing ⌃Q when the caret is inside a multi-part method call will align the method-parts at the colon(:) under each other.

    [NSEvent enterExitEventWithType:anEventType location:aPoint modifierFlags:flags timestamp:aTimeInterval
    	 windowNumber:number context:aGraphicsContext eventNumber:x trackingNumber:tracker userData:data]
    
Will be reformatted as

    [NSEvent enterExitEventWithType:anEventType
                           location:aPoint
                      modifierFlags:flags
                          timestamp:aTimeInterval
                       windowNumber:number
                            context:aGraphicsContext
                        eventNumber:x
                     trackingNumber:tracker
                           userData:data]
    
By default the inner brackets will be reformatted if the brackets are nested, move the caret to a non nested area to get the outer methods reformatted.

# Documentation Look-up

Documentation look-up exist for most everything defined in the Cocoa framework, class names method names types etc. It is invoked by pressing ⌃H when the caret is located on whatever you want to look up documentation for. Apple documentation is currently (Tiger) a little inconsistent when it comes to destination anchors, so redirects can sometimes fail, but the command will bring up the correct document page.


[0]: http://home.mac.se/joachimm/Post.html
[1]: http://home.mac.se/joachimm/TextMateObjCScreenCast.mov
[2]: http://macromates.com/screencasts

MARKDOWN
html_footer</string>
	<key>input</key>
	<string>none</string>
	<key>name</key>
	<string>Help</string>
	<key>output</key>
	<string>showAsHTML</string>
	<key>scope</key>
	<string>source.objc, source.objc++</string>
	<key>uuid</key>
	<string>AFB40870-6F83-4211-9362-0538287B52A9</string>
</dict>
</plist>
